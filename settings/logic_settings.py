"""
По сути здесь хранятся константы для обработки логики.
"""

# =====================Настройки для get_xlsx.py=====================
# =====================Ключи для проверки файлов=====================
# По этим текстовым ключам проверяется каждый файл. Если указанного
# куска текста нет в указанном файле, значит файл был выбран в
# неправильном текстовом поле.
# Принцип: ищем в первых строках файла текст, который соответствует ключам.
# если текст найден, то файл выбран правильно. Если нет, райзим ошибку.
# Например: файл ВИК был выбран в поле для файлов Стилоскопирования.

# Ключ для проверки протоколов визуального и измерительного контроля (ВИК)
VMC_CHECK_KEYS = ["визуальн"]  # Default ["визуальн"]

# Ключ для проверки протоколов замеров твердости
HB_CHECK_KEYS = ["твердост", "твёрдост"]  # Default ["твердост", "твёрдост"]

# Ключ для проверки протоколов радиографического контроля (РК или УЗК)
# Default ["радиограф", "ультразвук"]
RC_CHECK_KEYS = ["радиограф", "ультразвук"]

# Ключ для проверки протоколов стилоскопирования (СТ)
ST_CHECK_KEYS = ["флуоресцент"]  # Default ["флуоресцент"]

# Ключ для проверки протоколов цветной дефектоскопии (ЦД)
CD_CHECK_KEYS = ["капилляр"]  # Default ["капилляр"]

# Ключи у словаря files_dict у нас тоже настраиваемые и могут быть любыми,
# поэтому перенесем имена ключей в константы.
# Кстати, итоговый словарь, в котором хранятся типы контроля и даты контроля
# каждого типа для каждого шва у нас пока хранится в файле parser.py и
# структура такая:
# {<номер_шва>: {<тип_контроля>: <дата_контроля>}}
# В create_summary нам нужно будет вытащить даты контроля для каждого шва по
# типу контроля, где мы будем использовать эти же константы

# Ключ для визуального и измерительного контроля
VMC = 'vmc'  # Default: 'vmc'
# Ключ для контроля твердости
HB = 'hb'  # Default: 'hb'
# Ключ для радиографического или ультразвукового контроля
RC = 'rc'  # Default: 'rc'
# Ключ для ренгенофуоресцентного контроля или стилоскопирования
ST = 'st'  # Default: 'st'
# Ключ для цветной дефектоскопии
CD = 'cd'  # Default: 'cd'

# ========================Остальные настройки========================

# Разделитель, который используется для строки, содержащей путь к файлу.
# Необходим для получения имени файла из пути к нему.
FILEPATH_DIVIDER = '/'  # Default: '/'

# Разделитель, который используется для строки, содержащей имя файла.
# Необходим для получения разрешения файла из его имени.
# рекомендуется не трогать
EXTENSION_DIVIDER = '.'  # Default: '.'

# Разрешения, которые допустимы для файлов
EXTENSIONS = ['xlsx']

# Значения, которые определяют, с какой по какую строку мы будем искать
# совпадения по ключам для проверки файлов.
MIN_ROW_RANGE_VALUE = 1  # Default: 1
MAX_ROW_RANGE_VALUE = 11  # Default: 10

# ======================Настройки для parser.py======================

# Регулярное выражение для поиска номера шва. Обычно название шва состоит из
# одной буквы кириллицы, означающей тип шва и случайного набора чисел,
# чередующихся с дефисами.
# Варианты букв могут быть только определенные:
# С криллица или латиница - стыковой шов
# Н криллица или латиница - нахлесточный шов
# Т криллица или латиница - тавровый шов
# У или Y (редко) - угловой шов
# N - нестандартный шов
# Примеры наименования швов, подходящих под регулярное выражение:
# C-1
# T12-1-1
# N3-3
# Номера швов, которые не встречаются, но тоже подходят:
# C---1
# H11-1-
# T-
# Номера швов, которые не подойдут:
# A1-1
# Это_номер_шва
# TT-1-1-1
WELD_ID_REGEXP = r'^[CYTNHСНТУ][-\d]*$'  # Default: r'^[CYTNHСНТУ][-\d]*$'

# Поскольку в номерах швов у нас должны быть только кириллические буквы,
# но имеются также и похожие буквы латиницы, то благодаря человеческому
# фактору, один и тот же номер шва в разных протоколах может быть написан
# в разной раскладке. Особенно это касается буквы С, которая находится на
# одной и той же клавише, независимо от раскладки и это самый ебланский
# косяк чувака, который придумал раскладку ЙЦУКЕН. Отдельно можно было бы
# еще сказать про то, что чтобы запятую написать, я должен шифт зажимать,
# но это уже совсем другая история.
# В связи с чем, нужно для каждого номера шва менять букву латиницы на
# букву кириллицы. Этот словарь нужен для такого сопоставления букв.
# Default:
# {
#     'C': 'С',  # Английская C на русскую С
#     'H': 'Н',  # Английская H на русскую Н
#     'T': 'Т',  # Английская T на русскую Т
#     'Y': 'У'   # Английская Y на русскую У
# }
REPLACEMENT_DICT = {
    'C': 'С',  # Английская C на русскую С
    'H': 'Н',  # Английская H на русскую Н
    'T': 'Т',  # Английская T на русскую Т
    'Y': 'У'   # Английская Y на русскую У
}

# Обычно, дата в экселе отображается как объект datetime, но если, по
# каким-то причинам, дата преобразована в строку, то не мешало бы проверить
# и это.
# Эта регулярка нужна для проверки значения текущей ячейки на соответсвие его
# одному из форматов даты.
# А форматы могут быть такие:
# 1. С одной или двумя цифрами для номера дня и месяца.
# 2. С двумя или четырьмя цифрами для номера года.
# 3. С разделителем в виде точки, слеша или дефиса.
# Default: r'\d{1,2}[-/.]\d{1,2}[-/.]\d{2,4}'
DATE_REGEXP = r'\d{1,2}[-/.]\d{1,2}[-/.]\d{2,4}'

# В конце концов, какой бы не была дата, мы преобразуем ее в полюбившийся
# почти всем формат типа дд/мм/гггг. Ебанем универсалочку, так сказать. В
# таком формате дата будет отображена в итоговом сгенерированном файле.
DATE_FORMAT = "%d/%m/%Y"  # Default: "%d/%m/%Y"

# ==================Настройки для create_summary.py==================

# Имена колонок для генерируемой таблицы. Идут слева направо по порядку
# их перечисления в списке.
# Лучше ничего не добавлять и не удалять, а то все по пизде пойдет.
# Но переименовывать можно. В будущем исправлю.
# Default:
# [
#    "Номер шва",
#    "ВИК",
#    "Твёрдость",
#    "Стилоскопирование",
#    "РК или УЗК",
#    "ЦД",
#    "Примечания"
# ]
HEADERS = [
    "Номер шва",
    "ВИК",
    "Твёрдость",
    "Стилоскопирование",
    "РК или УЗК",
    "ЦД",
    "Примечания"
]

# Тут должны были быть константы для ключей типа VMC, CD, RC, HB и ST,
# но я их перенес выше, так как они используются сразу в двух файлах.
# Ищи их там

# Дефолтное значение ячейки в столбце с примечаниями:
NOTE = ""  # Default: ""

# Ниже значения, которые мы будем дописывать в note, когда какая-то из дат
# прописана неверно. Название констант будет составляться так:
# NOTE_<тип_контроля>_LT(less_than)_<другой_тип_контроля>, что означает,
# что контроль <тип_контроля> проведен раньше, чем <другой_тип_контроля>,
# что является ошибкой и такого быть не должно.

# Default: "Замер твердости проведен раньше ВИК; "
NOTE_HB_LT_VMC = "Замер твердости проведен раньше ВИК; "
# Default: "Стилоскопирование проведено раньше ВИК; "
NOTE_ST_LT_VMC = "Стилоскопирование проведено раньше ВИК; "
# Default: "Стилоскопирование проведено раньше замеров твердости; "
NOTE_ST_LT_HB = "Стилоскопирование проведено раньше замеров твердости; "
# Default: "РК или УЗК проведено раньше ВИК; "
NOTE_RC_LT_VMC = "РК или УЗК проведено раньше ВИК; "
# Default: "РК или УЗК проведено раньше замеров твердости; "
NOTE_RC_LT_HB = "РК или УЗК проведено раньше замеров твердости; "
# Default: "РК или УЗК проведено раньше стилоскопирования; "
NOTE_RC_LT_ST = "РК или УЗК проведено раньше стилоскопирования; "
# Default: "ЦД проведена раньше ВИК; "
NOTE_CD_LT_VMC = "ЦД проведена раньше ВИК; "
# Default: "ЦД проведена раньше замеров твердости; "
NOTE_CD_LT_HB = "ЦД проведена раньше замеров твердости; "
# Default: "ЦД проведена раньше замеров стилоскопирования; "
NOTE_CD_LT_ST = "ЦД проведена раньше замеров стилоскопирования; "
# Default: "ЦД проведена раньше замеров РК или УЗК; "
NOTE_CD_LT_RC = "ЦД проведена раньше замеров РК или УЗК; "
# Default: "Дата ВИК не указана!"
NOTE_VMC_DOES_NOT_EXIST = "Дата ВИК не указана!"
