"""
По сути здесь хранятся константы для обработки логики.
"""

# =====================Настройки для get_xlsx.py=====================
# =====================Ключи для проверки файлов=====================
# По этим текстовым ключам проверяется каждый файл. Если указанного
# куска текста нет в указанном файле, значит файл был выбран в 
# неправильном текстовом поле.
# Принцип: ищем в первых строках файла текст, который соответствует ключам.
# если текст найден, то файл выбран правильно. Если нет, райзим ошибку.
# Например: файл ВИК был выбран в поле для файлов Стилоскопирования.

# Ключ для проверки протоколов визуального и измерительного контроля (ВИК)
VMC_CHECK_KEYS = ["визуальн"] # Default ["визуальн"]

# Ключ для проверки протоколов замеров твердости
HB_CHECK_KEYS = ["твердост", "твёрдост"] # Default ["твердост", "твёрдост"]

# Ключ для проверки протоколов радиографического контроля (РК или УЗК)
# Default ["радиограф", "ультразвук"]
RC_CHECK_KEYS = ["радиограф", "ультразвук"] 

# Ключ для проверки протоколов стилоскопирования (СТ)
ST_CHECK_KEYS = ["флуоресцент"] # Default ["флуоресцент"]

# Ключ для проверки протоколов цветной дефектоскопии (ЦД)
CD_CHECK_KEYS = ["капилляр"] # Default ["капилляр"]

# ========================Остальные настройки========================

# Разделитель, который используется для строки, содержащей путь к файлу.
# Необходим для получения имени файла из пути к нему.
FILEPATH_DIVIDER = '/' # Default: '/'

# Разделитель, который используется для строки, содержащей имя файла.
# Необходим для получения разрешения файла из его имени.
# рекомендуется не трогать
EXTENSION_DIVIDER = '.' # Default: '.'

# Разрешения, которые допустимы для файлов
EXTENSIONS = ['xlsx']

# Значения, которые определяют, с какой по какую строку мы будем искать
# совпадения по ключам для проверки файлов.
MIN_ROW_RANGE_VALUE = 1 # Default: 1
MAX_ROW_RANGE_VALUE = 11 # Default: 10 

# ======================Настройки для parser.py======================

# Регулярное выражение для поиска номера шва. Обычно название шва состоит из
# одной буквы кириллицы, означающей тип шва и случайного набора чисел,
# чередующихся с дефисами.
# Варианты букв могут быть только определенные:
# С криллица или латиница - стыковой шов
# Н криллица или латиница - нахлесточный шов
# Т криллица или латиница - тавровый шов
# У или Y (редко) - угловой шов
# N - нестандартный шов
# Примеры наименования швов, подходящих под регулярное выражение:
# C-1
# T12-1-1
# N3-3
# Номера швов, которые не встречаются, но тоже подходят:
# C---1
# H11-1-
# T-
# Номера швов, которые не подойдут:
# A1-1
# Это_номер_шва
# TT-1-1-1
WELD_ID_REGEXP = r'^[CYTNHСНТУ][-\d]*$'

# Поскольку в номерах швов у нас должны быть только кириллические буквы,
# но имеются также и похожие буквы латиницы, то благодаря человеческому
# фактору, один и тот же номер шва в разных протоколах может быть написан
# в разной раскладке. Особенно это касается буквы С, которая находится на 
# одной и той же клавише, независимо от раскладки и это самый ебланский
# косяк чувака, который придумал раскладку ЙЦУКЕН. Отдельно можно было бы
# еще сказать про то, что чтобы запятую написать, я должен шифт зажимать,
# но это уже совсем другая история.
# В связи с чем, нужно для каждого номера шва менять букву латиницы на
# букву кириллицы. Этот словарь нужен для такого сопоставления букв.
REPLACEMENT_DICT = {
    'C': 'С',  # Английская C на русскую С
    'H': 'Н',  # Английская H на русскую Н
    'T': 'Т',  # Английская T на русскую Т
    'Y': 'У'   # Английская Y на русскую У
}

# Обычно, дата в экселе отображается как объект datetime, но если, по
# каким-то причинам, дата преобразована в строку, то не мешало бы проверить
# и это. 
# Эта регулярка нужна для проверки значения текущей ячейки на соответсвие его
# одному из форматов даты.
# А форматы могут быть такие:
# 1. С одной или двумя цифрами для номера дня и месяца.
# 2. С двумя или четырьмя цифрами для номера года.
# 3. С разделителем в виде точки, слеша или дефиса.
DATE_REGEXP = r'\d{1,2}[-/.]\d{1,2}[-/.]\d{2,4}'

# В конце концов, какой бы не была дата, мы преобразуем ее в полюбившийся
# почти всем формат типа дд/мм/гггг. Ебанем универсалочку, так сказать. В
# таком формате дата будет отображена в итоговом сгенерированном файле.
DATE_FORMAT = "%d/%m/%Y"
